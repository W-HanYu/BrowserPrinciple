# HTTP3：甩掉TCP、TCL包袱，构建高效网络

前面两篇文章我们分析了 HTTP / 1 和 HTTP / 2，在 HTTP / 2 出现之前，开发者需要采用很多变通的方式来解决 HTTP / 1 所存在的问题，不过 HTTP / 2 在 2018 年就开始得到了大规模的应用，HTTP / 1 中存在的一大堆缺陷都得到了解决。

HTTP / 2 的一个核心特性是使用了多路复用技术，因此它可以通过一个 TCP 连接来发送多个 URL 请求。多路复用技术能充分利用带宽，最大限度规避了 TCP 的慢启动所带来的问题，同时还实现了头部压缩、服务器推送等功能，使得页面资源的传输速度得到了大幅提升。在 HTTP / 1.1 时代，为了提升并行下载效率，浏览器为每个域名维护了 6 个 TCP 连接；而采用 HTTP / 2 之后，浏览器只需要为每个域名维护 1 个 TCP 持久连接，同时还解决了 HTTP / 1.1 队头阻塞的问题。

从目前的情况来看，HTTP / 2 似乎可以完美取代 HTTP / 1 了，不过 HTTP / 2 依然存在一些缺陷，于是就有了 HTTP / 3。和通常一样，介绍 HTTP / 3 之前，我们先来看看 HTTP / 2 到底有什么缺陷。

## TCP 的队头阻塞

虽然 HTTP / 2 解决了应用层面的队头阻塞问题，不过和 HTTP / 1.1 一样，HTTP / 2 依然是基于 TCP 协议的，而 TCP 最初就是为了单连接而设计的。你可以把 TCP 连接看成是两台计算机之前的一个虚拟管道，计算机的一端将要传输的数据按照顺序放入管道，最终数据会以相同的顺序出现在管道的另外一头。

接下来我们就来分析下，HTTP / 1.1 协议栈中 TCP 是如何传输数据的。为了直观理解，你可以参考下图：

![正常情况下的TCP传输数据过程](./img/tcp-transfer-data-process.png)

通过上图你会发现，从一端发送给另外一端的数据会被拆分为一个个按照顺序排列的数据包，这些数据包通过网络传输到了接收端，接收端再按照顺序将这些数据包组合成原始数据，这样就完成了数据传输。

不过，如果在数据传输的过程中，有一个数据因为网络故障或者其他原因而丢包了，那么整个 TCP 的连接就会处于暂停状态，需要等待丢失的数据包被重新传输过来。你可以把 TCP 连接看成是一个按照顺序传输数据的管道，管道中的任意一个数据丢失了，那之后的数据都需要等待该数据的重新传输。为了直观理解，你可以参考下图：

![TCP丢包状态](./img/tcp-packet-loss-status.png)

我们就把在 TCP 传输过程中，由于单个数据包的丢失而造成的阻塞称为 TCP 上的队头阻塞。

那队头阻塞是怎么影响 HTTP / 2 传输的呢？首先我们来看正常情况下 HTTP / 2 是怎么传输多路请求的，为了直观理解，你可以参考下图：

![HTTP/2多路复用](./img/http-2-multiplexing.png)

通过该图，我们知道在 HTTP / 2 中，多个请求是跑在一个 TCP 管道中的，如果任意一路数据流中出现了丢包的情况，那么就会阻塞该 TCP 连接中的所有请求。这不同于 HTTP / 1.1，使用 HTTP / 1.1 时，浏览器为每个域名开启了 6 个 TCP 连接，如果其中的 1 个 TCP 连接发生了队头阻塞，那么其他的 5 个连接依然可以继续传输数据。

所以随着丢包率的增加，HTTP / 2 的传输率也会越来越差。有测试数据表明，当系统达到了 2% 的丢包率时，HTTP / 1.1 的传输效率反而比 HTTP / 2 表现得更好。
